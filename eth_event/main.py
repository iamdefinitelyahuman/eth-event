#!/usr/bin/python3

from typing import Dict, List

from eth_abi import decode_abi, decode_single
from eth_abi.exceptions import InsufficientDataBytes
from eth_hash.auto import keccak
from hexbytes import HexBytes


class ABIError(Exception):
    pass


class EventError(Exception):
    pass


class StructLogError(Exception):
    pass


class UnknownEvent(Exception):
    pass


def get_log_topic(event_abi: Dict) -> str:
    """
    Generate an encoded event topic for an event.

    Arguments
    ---------
    event_abi : Dict
        Dictionary from a contract ABI, describing a specific event.

    Returns
    -------
    str
        bytes32 encoded topic for the event.
    """
    if not isinstance(event_abi, dict):
        raise TypeError("Must be a dictionary of the specific event's ABI")
    if event_abi["anonymous"]:
        raise ABIError("Anonymous events do not have a topic")

    types = _params(event_abi["inputs"])
    key = f"{event_abi['name']}({','.join(types)})".encode()

    return "0x" + keccak(key).hex()


def get_topic_map(abi: List) -> Dict:
    """
    Generate a dictionary of event topics from an ABI.

    This dictionary is required by `decode_log`, `decode_logs`, and
    `decode_traceTransaction`.

    Anonymous events are ignored. The return data is formatted as follows:

        {
            'encoded bytes32 topic': {
                'name':"Event Name",
                'inputs': [abi inputs]
            }
        }

    Arguments
    ---------
    abi : List
        Contract ABI

    Returns
    -------
    Dict
        Mapping of contract events.
    """
    try:
        events = [i for i in abi if i["type"] == "event" and not i["anonymous"]]
        return {get_log_topic(i): {"name": i["name"], "inputs": i["inputs"]} for i in events}

    except (KeyError, TypeError):
        raise ABIError("Invalid ABI")


def decode_log(log: Dict, topic_map: Dict) -> Dict:
    """
    Decode a single event log from a transaction receipt.

    Indexed arrays cannot be decoded. The returned value will still
    be encoded. Anonymous events and events where the topic is not found in
    `topic_map` will raise an exception.

    The return data is formatted as follows:

    {
        'name': "",  # event name
        'decoded': True / False,
        'data': [{
            'name': "",  # variable name
            'type': "",  # type as given by the ABI
            'value': "",  # decoded value, formatted by `eth_abi.decode_single`
            'decoded': True / False
        }, ...]
    }

    Arguments
    ---------
    log : Dict
        Event log as returned from the `eth_getTransactionReceipt` RPC endpoint.
    topic_map : Dict
        Contract event map generated by `get_topic_map`

    Returns
    -------
    Dict
        Decoded event log.
    """
    if not log["topics"]:
        raise EventError("Cannot decode an anonymous event")

    key = HexBytes(log["topics"][0]).hex()
    if key not in topic_map:
        raise UnknownEvent("Event topic is not present in given ABI")
    abi = topic_map[key]

    try:
        return {
            "name": abi["name"],
            "data": _decode(abi["inputs"], log["topics"][1:], log["data"]),
            "decoded": True,
        }
    except (KeyError, TypeError):
        raise EventError("Invalid event")


def decode_logs(logs: List, topic_map: Dict, allow_undecoded: bool = False) -> List:
    """
    Decode a list of event logs from a transaction receipt.

    If `allow_undecoded` is `True`, an undecoded event is returned with the
    following structure:

    {
        'name': None,
        'decoded': False,
        'data': "",  # raw data hexstring
        'topics': [],  # list of undecoded topics as 32 byte hexstrings
    }

    Arguments
    ---------
    logs : List
        List of event logs as returned from the `eth_getTransactionReceipt`
        RPC endpoint.
    topic_map : Dict
        Contract event map generated by `get_topic_map`
    allow_undecoded: bool, optional
        Determines how undecodable events are handled. If `True`, they are
        returned

    Returns
    -------
    List
        A list of decoded events, formatted in the same structure as `decode_log`
    """
    events = []

    for item in logs:
        topics = [HexBytes(i).hex() for i in item["topics"]]
        if not topics or topics[0] not in topic_map:
            if not allow_undecoded:
                raise UnknownEvent("Log contains undecodable event")
            event = {
                "name": None,
                "topics": topics,
                "data": HexBytes(item["data"]).hex(),
                "decoded": False,
            }
        else:
            event = decode_log(item, topic_map)
        events.append(event)

    return events


def decode_traceTransaction(
    struct_logs: List, topic_map: Dict, allow_undecoded: bool = False
) -> List:
    """
    Extract and decode a list of event logs from a transaction traceback.

    Useful for obtaining the events fired in a transaction that reverted.

    Arguments
    ---------
    struct_logs : List
        `structLogs` field from Geth's `debug_traceTransaction` RPC endpoint
    topic_map : Dict
        Contract event map generated by `get_topic_map`
    allow_undecoded: bool, optional
        If `False`, an exception is raised when an event cannod be decoded.

    Returns
    -------
    List
        A list of decoded events, formatted in the same structure as `decode_log`
    """
    events = []

    for item in (i for i in struct_logs if i["op"].startswith("LOG")):
        try:
            offset = int(item["stack"][-1], 16) * 2
            length = int(item["stack"][-2], 16) * 2
            topic_len = int(item["op"][-1])
            topics = [HexBytes(i).hex() for i in item["stack"][-3 : -3 - topic_len : -1]]
        except KeyError:
            raise StructLogError("StructLog has no stack")
        except (IndexError, TypeError):
            raise StructLogError("Malformed stack")

        try:
            data = "".join(item["memory"])[offset : offset + length]
        except (KeyError, TypeError):
            raise StructLogError("Malformed memory")

        if not topics or topics[0] not in topic_map:
            if not allow_undecoded:
                raise UnknownEvent("Log contains undecodable event")
            result = {
                "name": None,
                "topics": topics,
                "data": HexBytes(data).hex(),
                "decoded": False,
            }
        else:
            result = {
                "name": topic_map[topics[0]]["name"],
                "data": _decode(topic_map[topics[0]]["inputs"], topics[1:], data),
                "decoded": True,
            }
        events.append(result)

    return events


def _params(abi_params: List) -> List:
    types = []
    for i in abi_params:
        if i["type"] != "tuple":
            types.append(i["type"])
            continue
        types.append(f"({','.join(x for x in _params(i['components']))})")

    return types


def _decode(inputs: List, topics: List, data: str) -> List:
    try:
        types = _params([i for i in inputs if not i["indexed"]])
    except (KeyError, TypeError):
        raise ABIError("Invalid ABI")

    if types and data == "0x":
        data += "0" * (len(types) * 64)

    try:
        decoded = list(decode_abi(types, HexBytes(data)))[::-1]
    except InsufficientDataBytes:
        raise EventError("Insufficient event data")
    except OverflowError:
        raise EventError("Cannot decode event due to overflow error")

    topics = topics[::-1]
    result = []
    for i in inputs:
        result.append({"name": i["name"], "type": i["type"]})
        if "components" in i:
            result[-1]["components"] = i["components"]
        if i["indexed"]:
            if not topics:
                raise EventError("Insufficient event data")
            encoded = HexBytes(topics.pop())
            try:
                value = decode_single(i["type"], encoded)
            except (InsufficientDataBytes, OverflowError):
                result[-1].update({"value": encoded.hex(), "decoded": False})
                continue
        else:
            value = decoded.pop()
        if isinstance(value, bytes):
            value = HexBytes(value).hex()
        result[-1].update({"value": value, "decoded": True})

    return result
